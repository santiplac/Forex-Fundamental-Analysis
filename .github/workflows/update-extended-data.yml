name: Update Extended Data (Bonds + Sentiment + Flows + rateMomentum) - v10

on:
  schedule:
    - cron: '30 6 * * *'
  workflow_dispatch:

jobs:
  update-extended-data:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: pip install requests beautifulsoup4 lxml --break-system-packages

      - name: Create directory
        run: mkdir -p extended-data

      - name: Scrape extended indicators
        run: |
          python3 << 'EOFPYTHON'
          import requests
          from bs4 import BeautifulSoup
          import json, re, os, time, csv
          from io import StringIO
          from datetime import date, datetime, timedelta

          HEADERS = {
              'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
              'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
          }

          CURRENCIES = ['USD', 'EUR', 'GBP', 'JPY', 'CAD', 'AUD', 'CHF', 'NZD']

          COUNTRY_NAMES = {
              'USD': ['United States'],
              'EUR': ['Euro Area'],
              'GBP': ['United Kingdom'],
              'JPY': ['Japan'],
              'CAD': ['Canada'],
              'AUD': ['Australia'],
              'CHF': ['Switzerland'],
              'NZD': ['New Zealand']
          }

          TE_URLS = {
              'bond10y':               'https://tradingeconomics.com/country-list/government-bond-yield?continent=world',
              'consumerConfidence':    'https://tradingeconomics.com/country-list/consumer-confidence?continent=world',
              'businessConfidence':    'https://tradingeconomics.com/country-list/business-confidence?continent=world',
              'capitalFlows':          'https://tradingeconomics.com/country-list/capital-flows?continent=world',
              'fdi':                   'https://tradingeconomics.com/country-list/foreign-direct-investment?continent=world',
              'inflationExpectations': 'https://tradingeconomics.com/country-list/inflation-expectations?continent=world',
          }

          BONDS_MARKET_PAGE = 'https://tradingeconomics.com/bonds'

          # â”€â”€ FX RATES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          exchange_rates = {}

          def fetch_fx():
              global exchange_rates
              try:
                  r = requests.get('https://api.frankfurter.app/latest?from=USD', timeout=10)
                  if r.ok:
                      exchange_rates = r.json().get('rates', {})
                      exchange_rates['USD'] = 1.0
                      print(f"  âœ… FX rates loaded: {sorted(exchange_rates.keys())}")
                      return True
              except Exception as e:
                  print(f"  âš ï¸ FX fetch failed: {e}")
              exchange_rates = {
                  'USD': 1.0, 'EUR': 0.92, 'GBP': 0.79, 'JPY': 150.0,
                  'CAD': 1.36, 'AUD': 1.57, 'CHF': 0.90, 'NZD': 1.67,
              }
              print("  âš ï¸ Using fallback FX rates")
              return False

          # â”€â”€ HELPERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          def clean_num(text):
              if not text: return None
              text = str(text).strip().replace(',','').replace('%','')
              m = re.search(r'(-?\d+\.?\d*)', text)
              return float(m.group(1)) if m else None

          def parse_te_date(date_text):
              if not date_text: return str(date.today())
              date_text = date_text.strip()
              try:
                  m = re.match(r'^([A-Za-z]{3})/(\d{2})$', date_text)
                  if m:
                      dt = datetime.strptime(f"{m.group(1)} 20{m.group(2)}", '%b %Y')
                      return dt.strftime('%Y-%m-15')
                  m = re.match(r'^([A-Za-z]{3})\s+(\d{4})$', date_text)
                  if m:
                      dt = datetime.strptime(f"{m.group(1)} {m.group(2)}", '%b %Y')
                      return dt.strftime('%Y-%m-15')
                  m = re.search(r'Q(\d)[/\s](\d{4})', date_text)
                  if m:
                      month = (int(m.group(1)) - 1) * 3 + 2
                      return f"{m.group(2)}-{month:02d}-15"
              except: pass
              return str(date.today())

          # â”€â”€ v10: rateMomentum â€” mÃºltiples estrategias â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          def scrape_rate_momentum():
              print(f"\n{'='*50}\nRATE MOMENTUM (v10 â€” TE API guest + FRED + bootstrap)\n{'='*50}")
              momentum = {}
              momentum_dates = {}
              momentum_source = {}

              today     = datetime.today()
              target_dt = today - timedelta(days=365)

              TE_COUNTRY_SLUGS = {
                  'USD': 'united-states',
                  'EUR': 'euro-area',
                  'GBP': 'united-kingdom',
                  'JPY': 'japan',
                  'CAD': 'canada',
                  'AUD': 'australia',
                  'CHF': 'switzerland',
                  'NZD': 'new-zealand',
              }

              # â”€â”€ Estrategia 1: TE API guest â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
              print(f"\n  Estrategia 1: TE API guest")
              TE_API_HEADERS = {
                  'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                  'Accept': 'application/json',
                  'Referer': 'https://tradingeconomics.com/',
              }

              for code, slug in TE_COUNTRY_SLUGS.items():
                  if code in momentum:
                      continue
                  try:
                      url = f'https://api.tradingeconomics.com/historical/country/{slug}/indicator/interest-rate?c=guest:guest'
                      r = requests.get(url, headers=TE_API_HEADERS, timeout=15)

                      if r.status_code == 200:
                          data = r.json()
                          if not isinstance(data, list) or len(data) < 2:
                              print(f"    âš ï¸ {code}: respuesta vacÃ­a o insuficiente")
                              continue

                          obs = []
                          for item in data:
                              dt_str = item.get('DateTime') or item.get('Date') or ''
                              val    = item.get('Value')
                              if not dt_str or val is None:
                                  continue
                              try:
                                  dt_str_clean = dt_str[:10]
                                  obs_dt = datetime.strptime(dt_str_clean, '%Y-%m-%d')
                                  obs.append((obs_dt, float(val)))
                              except:
                                  continue

                          if len(obs) < 2:
                              print(f"    âš ï¸ {code}: menos de 2 observaciones parseadas")
                              continue

                          obs.sort(key=lambda x: x[0])
                          current_dt, current_rate = obs[-1]

                          closest_val, closest_diff, closest_dt = None, float('inf'), None
                          for obs_dt, obs_val in obs[:-1]:
                              diff = abs((obs_dt - target_dt).days)
                              if diff < closest_diff:
                                  closest_diff, closest_val, closest_dt = diff, obs_val, obs_dt

                          if closest_val is not None and closest_diff <= 60:
                              m_val = round(current_rate - closest_val, 4)
                              momentum[code]        = m_val
                              momentum_dates[code]  = current_dt.strftime('%Y-%m-%d')
                              momentum_source[code] = 'te-api-guest'
                              direction = 'â†‘' if m_val > 0.001 else ('â†“' if m_val < -0.001 else 'â†’')
                              print(f"    âœ“ {code}: {current_rate}% - {closest_val}% = {m_val:+.4f}% {direction} (ref: {closest_dt.strftime('%Y-%m')}, {closest_diff}d)")
                          else:
                              print(f"    âš ï¸ {code}: 12M target demasiado lejano ({closest_diff}d), {len(obs)} obs disponibles")

                      elif r.status_code == 401:
                          print(f"    âš ï¸ {code}: TE API requiere autenticaciÃ³n (401) â€” saltando estrategia 1")
                          break
                      elif r.status_code == 429:
                          print(f"    âš ï¸ Rate limited en TE API, esperando 30s...")
                          time.sleep(30)
                      else:
                          print(f"    âš ï¸ {code}: HTTP {r.status_code}")

                      time.sleep(1)

                  except Exception as e:
                      print(f"    âŒ {code}: {e}")

              # â”€â”€ Estrategia 2: FRED CSV â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
              FRED_SERIES = {
                  'USD': 'FEDFUNDS',
                  'EUR': 'ECBDFR',
                  'GBP': 'BOERUKM',
                  'JPY': 'IRSTCB01JPM156N',
              }
              fred_candidates = [c for c in CURRENCIES if c not in momentum and c in FRED_SERIES]
              if fred_candidates:
                  print(f"\n  Estrategia 2: FRED CSV para {', '.join(fred_candidates)}")
                  FRED_BASE = 'https://fred.stlouisfed.org/graph/fredgraph.csv?id='
                  for code in fred_candidates:
                      series_id = FRED_SERIES[code]
                      try:
                          r = requests.get(f'{FRED_BASE}{series_id}', timeout=15)
                          if r.status_code != 200:
                              print(f"    âš ï¸ {code}: FRED {r.status_code}")
                              continue
                          reader = csv.reader(StringIO(r.text))
                          rows = []
                          for row in reader:
                              if len(row) == 2 and row[0] != 'DATE' and row[1] not in ('.', ''):
                                  try:
                                      rows.append((datetime.strptime(row[0], '%Y-%m-%d'), float(row[1])))
                                  except: continue
                          if len(rows) < 2:
                              continue
                          latest_dt, current_rate = rows[-1]
                          target_dt_fred = latest_dt.replace(year=latest_dt.year - 1)
                          closest_val, closest_diff = None, float('inf')
                          for obs_dt, obs_val in rows[:-1]:
                              diff = abs((obs_dt - target_dt_fred).days)
                              if diff < closest_diff:
                                  closest_diff, closest_val = diff, obs_val
                          if closest_val is not None and closest_diff <= 45:
                              m_val = round(current_rate - closest_val, 4)
                              momentum[code]        = m_val
                              momentum_dates[code]  = latest_dt.strftime('%Y-%m-%d')
                              momentum_source[code] = 'fred'
                              direction = 'â†‘' if m_val > 0.001 else ('â†“' if m_val < -0.001 else 'â†’')
                              print(f"    âœ“ {code} [FRED {series_id}]: {current_rate}% - {closest_val}% = {m_val:+.4f}% {direction}")
                          time.sleep(0.5)
                      except Exception as e:
                          print(f"    âŒ {code}: {e}")

              # â”€â”€ Estrategia 3: Bootstrap con alerta de antigÃ¼edad â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
              # CORRECCIÃ“N: El bootstrap hardcodeado puede quedarse desactualizado.
              # Ahora se emite una advertencia cuando la referencia supera los 400 dÃ­as,
              # indicando que BOOTSTRAP_FALLBACK debe actualizarse manualmente.
              # Nota: los valores son correctos para calcular rateMomentum 12M
              # (se restan a la tasa actual), pero solo si reflejan la tasa real
              # de hace ~12 meses. Si cambian las tasas, actualizar estos valores.
              BOOTSTRAP_FALLBACK = {
                  'CAD': (3.00, '2025-02-01'),
                  'AUD': (4.35, '2025-02-01'),
                  'CHF': (0.50, '2025-02-01'),
                  'NZD': (3.75, '2025-02-01'),
              }

              bootstrap_candidates = [c for c in CURRENCIES if c not in momentum and c in BOOTSTRAP_FALLBACK]
              if bootstrap_candidates:
                  print(f"\n  Estrategia 3: Bootstrap dinÃ¡mico para {', '.join(bootstrap_candidates)}")

                  for code in bootstrap_candidates:
                      old_rate, old_date_str = BOOTSTRAP_FALLBACK[code]

                      # Verificar antigÃ¼edad de la referencia hardcodeada
                      try:
                          ref_date = datetime.strptime(old_date_str, '%Y-%m-%d')
                          age_days = (datetime.today() - ref_date).days
                          if age_days > 400:
                              print(f"    âš ï¸ {code}: referencia bootstrap tiene {age_days}d de antigÃ¼edad")
                              print(f"       â†’ Actualizar BOOTSTRAP_FALLBACK con la tasa real de hace ~12 meses")
                          elif age_days > 340:
                              print(f"    â„¹ï¸ {code}: referencia bootstrap tiene {age_days}d â€” pronto necesitarÃ¡ actualizaciÃ³n")
                          else:
                              print(f"    âœ“ {code}: referencia bootstrap tiene {age_days}d â€” dentro del rango vÃ¡lido (â‰¤400d)")
                      except Exception as e:
                          print(f"    âš ï¸ {code}: no se pudo verificar antigÃ¼edad del bootstrap: {e}")

                      # Leer tasa actual del archivo rates/{code}.json
                      try:
                          rates_path = f'rates/{code}.json'
                          current_rate = None
                          if os.path.exists(rates_path):
                              with open(rates_path) as f:
                                  rates_json = json.load(f)
                              obs = rates_json.get('observations', [])
                              if obs:
                                  val_str = obs[0].get('value', '')
                                  current_rate = clean_num(str(val_str))

                          if current_rate is None:
                              print(f"    âš ï¸ {code}: no se pudo leer tasa actual de rates/{code}.json")
                              continue

                          m_val = round(current_rate - old_rate, 4)
                          momentum[code]        = m_val
                          momentum_dates[code]  = str(date.today())
                          momentum_source[code] = 'bootstrap-feb2025'
                          direction = 'â†‘' if m_val > 0.001 else ('â†“' if m_val < -0.001 else 'â†’')
                          print(f"    âœ“ {code} [bootstrap]: {current_rate}% - {old_rate}% ({old_date_str}) = {m_val:+.4f}% {direction}")

                      except Exception as e:
                          print(f"    âŒ {code} bootstrap: {e}")

              # â”€â”€ Estrategia 4: Archivo anterior â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
              still_missing = [c for c in CURRENCIES if c not in momentum]
              if still_missing:
                  print(f"\n  Estrategia 4: Archivo anterior para {', '.join(still_missing)}")
                  for code in still_missing:
                      try:
                          path = f'extended-data/{code}.json'
                          if os.path.exists(path):
                              with open(path) as f:
                                  prev = json.load(f)
                              prev_val = prev.get('data', {}).get('rateMomentum')
                              if prev_val is not None:
                                  momentum[code]        = prev_val
                                  momentum_dates[code]  = prev.get('dates', {}).get('rateMomentum', str(date.today()))
                                  momentum_source[code] = 'previous-file'
                                  print(f"    âœ“ {code}: valor anterior {prev_val:+.4f}% [{momentum_dates[code]}]")
                              else:
                                  print(f"    âœ— {code}: sin valor anterior disponible")
                          else:
                              print(f"    âœ— {code}: no existe archivo anterior")
                      except Exception as e:
                          print(f"    âœ— {code}: {e}")

              # â”€â”€ Resumen â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
              print(f"\n  Estrategias usadas:")
              for code in CURRENCIES:
                  src = momentum_source.get(code, 'none')
                  val = momentum.get(code)
                  val_str = f"{val:+.4f}%" if val is not None else "null"
                  print(f"    {code}: {src} â†’ {val_str}")

              final_missing = [c for c in CURRENCIES if c not in momentum]
              if final_missing:
                  print(f"\n  âŒ rateMomentum no disponible para: {', '.join(final_missing)} (serÃ¡ null)")
              else:
                  print(f"\n  âœ… rateMomentum completo para todas las divisas")

              return momentum, momentum_dates, momentum_source

          # â”€â”€ CAPITAL FLOWS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          def parse_capital_flows_row(cols):
              if len(cols) < 5:
                  return None
              raw_val  = clean_num(cols[1].get_text(strip=True))
              unit_str = cols[4].get_text(strip=True)
              if raw_val is None or not unit_str:
                  return None
              unit_upper = unit_str.upper()
              if 'TRILLION' in unit_upper:
                  scale = 1_000_000.0
              elif 'BILLION' in unit_upper:
                  scale = 1_000.0
              elif 'HUNDRED MILLION' in unit_upper:
                  scale = 100.0
              elif 'MILLION' in unit_upper:
                  scale = 1.0
              else:
                  print(f"    âš ï¸ Escala desconocida '{unit_str}' â€” tratando como millones")
                  scale = 1.0
              m = re.match(r'^([A-Z]{3})\b', unit_upper)
              src_currency = m.group(1) if m else 'USD'
              val_native_millions = raw_val * scale
              if src_currency == 'USD':
                  val_usd_millions = val_native_millions
              else:
                  fx = exchange_rates.get(src_currency)
                  if fx and fx > 0:
                      val_usd_millions = val_native_millions / fx
                  else:
                      print(f"    âš ï¸ Sin tipo de cambio para {src_currency} â€” omitiendo")
                      return None
              return round(val_usd_millions, 2)

          # â”€â”€ CONFIDENCE NORMALIZATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          def normalize_confidence(value, currency, indicator):
              """
              Normaliza Ã­ndices de confianza a una escala base ~100.

              Divisas con escala nativa diferente a base-100:
                EUR/GBP  â†’ Ã­ndice europeo en escala negativa (-30 a +10) â†’ +100
                JPY      â†’ Ã­ndice japonÃ©s (rango 33-40) â†’ mapeo lineal
                CHF      â†’ SECO Consumer Climate (rango -40 a +10) â†’ +130

              Divisas que pasan el valor crudo SIN transformar (RAW_PASSTHROUGH):
                CAD â†’ Conference Board Canada (~40-130, tÃ­picamente ~49-100).
                      El index.html aplica su propia normalizaciÃ³n para CAD.
                NZD â†’ ANZ Business Outlook: balance neto centrado en 0.
                      El index.html lo re-mapea a base-100.
                USD â†’ Michigan Consumer Sentiment (~50-100): el index normaliza.
                AUD â†’ Westpac Consumer Confidence (~80-110): ya cerca de base-100.

              ValidaciÃ³n de rango (50-200): solo para divisas normalizadas aquÃ­
              (EUR, GBP, JPY, CHF). Las de RAW_PASSTHROUGH se excluyen porque
              sus valores crudos son intencionalmente fuera de ese rango.
              """
              if value is None:
                  return None

              VALID_RANGE = (50, 200)

              # Divisas que pasan el valor crudo al JSON sin transformaciÃ³n aquÃ­.
              # El index.html se encarga de normalizarlos segÃºn su escala nativa.
              RAW_PASSTHROUGH = {'CAD', 'NZD', 'USD', 'AUD'}

              result = None

              if indicator == 'consumerConfidence':
                  if currency in ('EUR', 'GBP'):
                      # Escala europea: tÃ­picamente -30 a +10 â†’ base 100
                      result = round(value + 100, 2)
                  elif currency == 'JPY':
                      # Escala japonesa: rango histÃ³rico ~33-42
                      result = round(((value - 40) / 10) * 15 + 100, 2)
                  elif currency == 'CHF':
                      # SECO Consumer Climate: rango -40 a +10 â†’ base 100
                      result = round(value + 130, 2)
                  else:
                      # CAD, USD, AUD, NZD: pasar crudo
                      result = round(value, 2)

              elif indicator == 'businessConfidence':
                  if currency in ('EUR', 'GBP', 'JPY', 'AUD'):
                      result = round(value + 100, 2)
                  else:
                      # CAD (Ivey PMI ~50), NZD (ANZ net balance), USD (ISM ~52):
                      # pasar crudo â€” el index.html normaliza segÃºn la divisa.
                      result = round(value, 2)

              else:
                  result = value

              # ValidaciÃ³n de rango: solo para divisas que normalizamos aquÃ­.
              # RAW_PASSTHROUGH se excluye para no rechazar valores legÃ­timos.
              if result is not None and currency not in RAW_PASSTHROUGH:
                  if not (VALID_RANGE[0] <= result <= VALID_RANGE[1]):
                      print(f"    âš ï¸ {currency} {indicator} normalizado fuera de rango: {result} (raw={value}) â†’ null")
                      return None

              return result

          # â”€â”€ GENERIC TABLE SCRAPER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          def scrape_te_table(url, label):
              print(f"\n{'='*50}\nSCRAPING: {label}\n{'='*50}")
              data, dates = {}, {}
              try:
                  r = requests.get(url, headers=HEADERS, timeout=20)
                  if r.status_code == 429:
                      print(f"  âš ï¸ Rate limited, esperando 30s...")
                      time.sleep(30)
                      r = requests.get(url, headers=HEADERS, timeout=20)
                  r.raise_for_status()

                  soup = BeautifulSoup(r.content, 'lxml')
                  table = soup.find('table', {'class': 'table'})
                  if not table:
                      print("  âŒ No se encontrÃ³ tabla"); return data, dates

                  headers_row = [h.get_text(strip=True).lower() for h in table.find_all('th')]
                  if 'actual' in headers_row:
                      actual_idx = headers_row.index('actual')
                  elif 'last' in headers_row:
                      actual_idx = headers_row.index('last')
                  else:
                      actual_idx = 1
                  date_idx = headers_row.index('reference') if 'reference' in headers_row else None

                  for row in table.find_all('tr')[1:]:
                      cols = row.find_all('td')
                      if len(cols) < 2: continue
                      ctry = cols[0].get_text(strip=True)
                      for code, names in COUNTRY_NAMES.items():
                          if any(n.lower() in ctry.lower() for n in names):
                              dt = parse_te_date(cols[date_idx].get_text(strip=True)) if date_idx and len(cols) > date_idx else str(date.today())

                              if label == 'capitalFlows':
                                  val_usd = parse_capital_flows_row(cols)
                                  if val_usd is not None:
                                      unit_str = cols[4].get_text(strip=True) if len(cols) > 4 else 'N/A'
                                      raw_str  = cols[1].get_text(strip=True)
                                      print(f"  âœ“ {code}: {raw_str} {unit_str} â†’ {val_usd:.1f} USD M ({dt})")
                                      data[code]  = val_usd
                                      dates[code] = dt
                              elif label in ('consumerConfidence', 'businessConfidence'):
                                  raw_val = clean_num(cols[actual_idx].get_text(strip=True))
                                  if raw_val is not None:
                                      normalized = normalize_confidence(raw_val, code, label)
                                      print(f"  âœ“ {code}: raw={raw_val} â†’ normalized={normalized} ({dt})")
                                      data[code]  = round(normalized, 4) if normalized is not None else None
                                      dates[code] = dt
                              else:
                                  raw_val = clean_num(cols[actual_idx].get_text(strip=True))
                                  if raw_val is not None:
                                      data[code]  = round(raw_val, 4)
                                      dates[code] = dt
                                      print(f"  âœ“ {code}: {raw_val} ({dt})")
                              break

              except Exception as e:
                  print(f"  âŒ {e}")
              return data, dates

          # â”€â”€ BOND YIELDS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          BOND_COUNTRY_MAP = {
              'USD': ['United States'],
              'EUR': ['Euro area'],
              'GBP': ['United Kingdom'],
              'JPY': ['Japan'],
              'CAD': ['Canada'],
              'AUD': ['Australia'],
              'CHF': ['Switzerland'],
              'NZD': ['New Zealand'],
          }
          BOND_COUNTRY_SLUGS = {
              'USD': 'united-states',
              'EUR': 'euro-area',
              'GBP': 'united-kingdom',
              'JPY': 'japan',
              'CAD': 'canada',
              'AUD': 'australia',
              'CHF': 'switzerland',
              'NZD': 'new-zealand',
          }
          BOND_EXPECTED_RANGES = {
              'USD': (3.0, 6.0),
              'EUR': (2.0, 4.5),
              'GBP': (3.5, 5.5),
              'JPY': (0.5, 3.5),
              'CAD': (2.5, 5.0),
              'AUD': (3.5, 6.0),
              'CHF': (0.0, 2.0),
              'NZD': (3.5, 6.0),
          }

          def _fetch_eur_bond_from_market_page():
              print(f"\n  â†’ Fetching EUR bond desde TE /bonds (GEUGB10Y â€” EA aggregate)...")
              try:
                  r = requests.get(BONDS_MARKET_PAGE, headers=HEADERS, timeout=20)
                  if r.status_code == 429:
                      print("  âš ï¸ Rate limited en /bonds, esperando 30s...")
                      time.sleep(30)
                      r = requests.get(BONDS_MARKET_PAGE, headers=HEADERS, timeout=20)
                  r.raise_for_status()
                  soup = BeautifulSoup(r.content, 'lxml')

                  ea_row = soup.find('tr', {'data-symbol': 'GEUGB10Y:GOV'})
                  if ea_row:
                      price_td = ea_row.find('td', {'id': 'p'})
                      date_td  = ea_row.find('td', {'id': 'date'})
                      if price_td:
                          val = clean_num(price_td.get_text(strip=True))
                          dt  = str(date.today())
                          if date_td:
                              dt = parse_te_date(date_td.get_text(strip=True))
                          if val is not None and 2.0 <= val <= 4.5:
                              print(f"  âœ“ EUR [/bonds GEUGB10Y â€” EA aggregate]: {val}% ({dt})")
                              return round(val, 3), dt
                          elif val is not None:
                              print(f"  âš ï¸ EUR GEUGB10Y={val}% fuera de rango esperado (2.0-4.5%) â€” descartando")

                  # Fallback: bÃºsqueda por texto "euro area" en la pÃ¡gina de bonds
                  for row in soup.find_all('tr'):
                      cells = row.find_all('td')
                      if len(cells) < 3: continue
                      for i, cell in enumerate(cells):
                          if 'euro area' in cell.get_text(strip=True).lower():
                              for price_cell in cells[i+1:]:
                                  val = clean_num(price_cell.get_text(strip=True))
                                  if val is not None and 2.0 <= val <= 4.5:
                                      print(f"  âœ“ EUR [/bonds text search]: {val}%")
                                      return round(val, 3), str(date.today())
                              break

              except Exception as e:
                  print(f"  âœ— EUR /bonds: {e}")
              return None, None

          def _extract_bonds_from_all_tables(soup):
              data, dates = {}, {}
              for table in soup.find_all('table'):
                  for row in table.find_all('tr'):
                      cols = row.find_all('td')
                      if len(cols) < 2: continue
                      ctry_text = cols[0].get_text(strip=True)
                      for code, names in BOND_COUNTRY_MAP.items():
                          if code in data: continue
                          if any(n.lower() in ctry_text.lower() for n in names):
                              for idx in [1, 2, 3]:
                                  if idx >= len(cols): continue
                                  val = clean_num(cols[idx].get_text(strip=True))
                                  if val is not None and 0 < val < 20:
                                      data[code]  = round(val, 3)
                                      dates[code] = str(date.today())
                                      print(f"  âœ“ {code}: {val}% (widget table)")
                                      break
              return data, dates

          def _bond_country_page_fallback(code):
              slug = BOND_COUNTRY_SLUGS.get(code)
              if not slug: return None, None
              min_val, max_val = BOND_EXPECTED_RANGES.get(code, (0.5, 10.0))
              url = f'https://tradingeconomics.com/{slug}/government-bond-yield'
              try:
                  r = requests.get(url, headers=HEADERS, timeout=15)
                  r.raise_for_status()
                  soup = BeautifulSoup(r.content, 'lxml')
                  for table in soup.find_all('table'):
                      for row in table.find_all('tr'):
                          cols = row.find_all('td')
                          for col in cols:
                              val = clean_num(col.get_text(strip=True))
                              if val is not None and min_val <= val <= max_val:
                                  print(f"  âœ“ {code}: {val}% (country page fallback)")
                                  return round(val, 3), str(date.today())
              except Exception as e:
                  print(f"  âŒ Country page fallback {code}: {e}")
              return None, None

          def scrape_bonds():
              print(f"\n{'='*50}\nBOND YIELDS (EUR via /bonds market page â€” GEUGB10Y EA aggregate)\n{'='*50}")
              data, dates = {}, {}

              # EUR: siempre intentar primero desde /bonds para obtener el agregado EA
              eur_val, eur_dt = _fetch_eur_bond_from_market_page()
              if eur_val is not None:
                  data['EUR']  = eur_val
                  dates['EUR'] = eur_dt
              time.sleep(1)

              # Resto de divisas: desde country-list
              try:
                  r = requests.get(TE_URLS['bond10y'], headers=HEADERS, timeout=20)
                  if r.status_code == 429:
                      print("  âš ï¸ Rate limited, esperando 30s...")
                      time.sleep(30)
                      r = requests.get(TE_URLS['bond10y'], headers=HEADERS, timeout=20)
                  r.raise_for_status()
                  soup = BeautifulSoup(r.content, 'lxml')

                  std_table = soup.find('table', {'class': 'table'})
                  if std_table:
                      headers_row = [h.get_text(strip=True).lower() for h in std_table.find_all('th')]
                      actual_idx = headers_row.index('actual') if 'actual' in headers_row else 1
                      if actual_idx == 1 and 'last' in headers_row:
                          actual_idx = headers_row.index('last')
                      date_idx = headers_row.index('reference') if 'reference' in headers_row else None
                      for row in std_table.find_all('tr')[1:]:
                          cols = row.find_all('td')
                          if len(cols) < 2: continue
                          ctry = cols[0].get_text(strip=True)
                          for code, names in BOND_COUNTRY_MAP.items():
                              if code == 'EUR': continue   # EUR ya cargado desde /bonds
                              if any(n.lower() in ctry.lower() for n in names):
                                  val = clean_num(cols[actual_idx].get_text(strip=True))
                                  dt  = parse_te_date(cols[date_idx].get_text(strip=True)) if date_idx and len(cols) > date_idx else str(date.today())
                                  min_v, max_v = BOND_EXPECTED_RANGES.get(code, (0, 20))
                                  if val is not None and min_v <= val <= max_v:
                                      data[code] = round(val, 3)
                                      dates[code] = dt
                                      print(f"  âœ“ {code}: {val}% ({dt})")
                                  elif val is not None:
                                      # CORRECCIÃ“N: loguear explÃ­citamente cuando se rechaza un valor
                                      print(f"  âœ— {code}: {val}% rechazado (fuera de rango esperado {min_v}-{max_v}%)")
                                  break

                  missing_non_eur = [c for c in CURRENCIES if c != 'EUR' and c not in data]
                  if missing_non_eur:
                      print(f"  Scanning all tables for: {', '.join(missing_non_eur)}")
                      w_data, w_dates = _extract_bonds_from_all_tables(soup)
                      for code in missing_non_eur:
                          if code in w_data:
                              min_v, max_v = BOND_EXPECTED_RANGES.get(code, (0, 20))
                              if min_v <= w_data[code] <= max_v:
                                  data[code]  = w_data[code]
                                  dates[code] = w_dates[code]
                              else:
                                  print(f"  âš ï¸ {code}: {w_data[code]}% fuera de rango â†’ descartado")

              except Exception as e:
                  print(f"  âŒ TE bond country-list error: {e}")

              still_missing = [c for c in CURRENCIES if c not in data]
              if still_missing:
                  print(f"\n  Country-page fallback para: {', '.join(still_missing)}")
                  for code in still_missing:
                      val, dt = _bond_country_page_fallback(code)
                      if val is not None:
                          data[code]  = val
                          dates[code] = dt
                      time.sleep(1)

              # CORRECCIÃ“N: ValidaciÃ³n cruzada EUR bond
              # Verificar que se obtuvo el agregado EA (GEUGB10Y ~2.5-3.0%)
              # y no el yield alemÃ¡n/Bund (~2.3-2.5%) que puede filtrarse en scrapers genÃ©ricos
              if 'EUR' in data:
                  eur_yield = data['EUR']
                  if eur_yield < 2.3:
                      print(f"\n  âš ï¸ EUR bond10y={eur_yield}% SOSPECHOSAMENTE BAJO")
                      print(f"     Posible captura del Bund alemÃ¡n en lugar del agregado EA (GEUGB10Y)")
                      print(f"     El yield EA oficial suele estar 15-25bp por encima del Bund")
                      print(f"     Revisar el scraper de /bonds si este valor persiste")
                  elif eur_yield > 3.5:
                      print(f"\n  âš ï¸ EUR bond10y={eur_yield}% SOSPECHOSAMENTE ALTO para zona euro")
                      print(f"     Rango esperado: 2.0-3.5%. Revisar fuente del dato.")
                  else:
                      print(f"\n  âœ“ EUR bond10y={eur_yield}% dentro del rango esperado para EA aggregate")
              else:
                  print(f"\n  âš ï¸ EUR bond10y: NO SE PUDO OBTENER â€” serÃ¡ null en el dashboard")

              print(f"\n  Found:   {[c for c in CURRENCIES if c in data]}")
              print(f"  Missing: {[c for c in CURRENCIES if c not in data]}")
              return data, dates

          # â”€â”€ MAIN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          print(f"\n{'='*50}\nFETCHING FX RATES\n{'='*50}")
          fetch_fx()

          all_data  = {c: {} for c in CURRENCIES}
          all_dates = {c: {} for c in CURRENCIES}

          # 1. Bond yields
          bond_data, bond_dates = scrape_bonds()
          for c in CURRENCIES:
              all_data[c]['bond10y']  = bond_data.get(c)
              all_dates[c]['bond10y'] = bond_dates.get(c, str(date.today()))
          time.sleep(2)

          # 2. Trading Economics indicators
          for key, url in {k: v for k, v in TE_URLS.items() if k != 'bond10y'}.items():
              d, dt = scrape_te_table(url, key)
              for c in CURRENCIES:
                  all_data[c][key]  = d.get(c)
                  all_dates[c][key] = dt.get(c, str(date.today()))
              time.sleep(2)

          # 3. rateMomentum
          rate_momentum, rate_momentum_dates, momentum_source = scrape_rate_momentum()
          for c in CURRENCIES:
              all_data[c]['rateMomentum']  = rate_momentum.get(c)
              all_dates[c]['rateMomentum'] = rate_momentum_dates.get(c, str(date.today()))

          # â”€â”€ GUARDAR RESULTADOS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          print(f"\n{'='*50}\nSAVING RESULTS\n{'='*50}")
          for curr in CURRENCIES:
              pkg = {
                  'lastUpdate': str(date.today()),
                  'source': 'TradingEconomics â€” v10: rateMomentum via TE API guest + FRED + bootstrap',
                  'rateMomentumStrategy': momentum_source.get(curr, 'none'),
                  'data':   all_data[curr],
                  'dates':  all_dates[curr]
              }
              with open(f'extended-data/{curr}.json', 'w') as f:
                  json.dump(pkg, f, indent=2)

              available = [k for k, v in all_data[curr].items() if v is not None]
              missing   = [k for k in ['bond10y','consumerConfidence','businessConfidence',
                                        'capitalFlows','inflationExpectations','rateMomentum']
                           if all_data[curr].get(k) is None]
              status = 'âœ…' if not missing else 'âš ï¸ '
              extras = []
              if curr == 'EUR':
                  extras.append(f"bond10y={all_data['EUR'].get('bond10y','N/A')}% EA agg")
              rm = all_data[curr].get('rateMomentum')
              if rm is not None:
                  direction = 'â†‘' if rm > 0.001 else ('â†“' if rm < -0.001 else 'â†’')
                  src = momentum_source.get(curr, 'unknown')
                  extras.append(f"rateMomentum={rm:+.4f}% {direction} [{src}]")
              cc = all_data[curr].get('consumerConfidence')
              if cc is not None:
                  extras.append(f"consumerConfidence={cc}")
              extra_str = f" [{', '.join(extras)}]" if extras else ''
              print(f"{status} {curr}: {', '.join(available) or 'NO DATA'}{extra_str}")
              if missing:
                  print(f"   Missing: {', '.join(missing)}")

          print("\nâœ… COMPLETE â€” v10")
          EOFPYTHON

      - name: Commit and push
        run: |
          git config user.name github-actions
          git config user.email github-actions@github.com
          git add extended-data/
          if git diff --quiet && git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "ğŸ“Š Extended data $(date +'%Y-%m-%d') â€” v10 rateMomentum TE API+FRED+bootstrap"
            git pull --rebase origin main || true
            git push
          fi
